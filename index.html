<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  <title>Low YS</title>
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <link href="style.css" rel="stylesheet">
</head>

<body>

    <h1>Hello, world!</h1>
    <p>
        My name is Low. I like to write programs and run those programs on a computer.
        Other things I enjoy: writing, board games, playing the piano, and reading.
    </p>

    <h3>Skills/Tools</h3>
    <ul>
        <li><b>Languages: </b>Javascript, Python, Scheme (Lisp), Java, C++, C</li>
        <li><b>Web development: </b>React, Redux, Nodejs, Express, MongoDB</li>
        <li><b>Machine Learning: </b>Keras, Dl4j, fastai</li>
        <li><b>General: </b>Git, Bash, Postman</li>
    </ul>

    <h3>Projects</h3>
    <ul>
        <li><a class="link">4-bit-adder</a> 4-bit adder circuit built on a breadboard (Figure 1)</li>
        <li><a class="link" href="https://blooming-falls-50778.herokuapp.com/" target="_blank">topsecretchatroom</a> Realtime chatroom application (access code: 42)</li>
        <!-- <li><a class="link" href="http://app.witeboard.io" target="_blank">witeboard.io</a> A-levels exam questions bank</li> -->
        <li><a class="link" href="https://lowysng.github.io/genetic" target="_blank">genetic</a> Evolutionary based optimiser</li>
        <li><a class="link" href="https://lowysng.github.io/pathfinder" target="_blank">pathfinder</a> Search algorithm visualiser</li>
        <li><a class="link" href="https://github.com/lowysng/sudoku-csp" target="_blank">sudoku-csp</a> Sudoku solver as a constraint satisfaction problem</li>
        <li><a class="link" href="https://github.com/lowysng/nand2tetris-js" target="_blank">nand2tetris-js</a> General purpose computer and assembler</li>
        <li><a class="link" href="http://shielded-bastion-60589.herokuapp.com/" target="_blank">neural-network</a> Neural network trainer</li>
        <li><a class="link" href="https://github.com/lowysng/turing-py" target="_blank">turing-py</a> Turing machine simulator</li>
    </ul>

    <div style="display: flex">
        <img src="adder.jpg" id="adder" width="250px">
        <p style="font-size: 12px; margin-left: 1em;">Figure 1. 4-bit adder</p>
    </div>

    <h3>Contact</h3>
    <a class="link" href="mailto:lowysng@gmail.com">lowysng@gmail.com</a>

    <hr>

    <h2>I Went to a Bad School</h2>

    <p>February 2021</p>

    <p>
        Hello, my name is Low and I am from Malaysia (just above Singapore). These days I spend most of my time 
        going through mathematics and computer science textbooks on my own. I have a list that I want to go through (see below), and I 
        am very optimistic that I will be able to go through all the books on the list (in its preliminary form) 
        in less than a year's time. 
    </p>

    <p>
        I know what you are thinking right now. "Why would anyone learn anything on their own instead of going to a school for it?", 
        "This guy is full of shit, there is no way anyone can self learn effectively without proper guidance from qualified mentors and or peers."
    </p>

    <p>
        When someone announces that they're an autodidact, your first response is probably that 
        they are full of shit, and that you should take anything they say afterward with a grain of salt. 
        If this is exactly your response after reading these paragraphs, then I suggest that you 
        stop reading now for there is no way I am able to change your position on the matter (not through this essay at least).
    </p>

    <p>
        But if you are willing to give me the benefit of the doubt, then that's great! My job now to persuade you that my approach is 
        indeed effective and that I am genuinely learning and achieving these goals that I have set for myself. And I thought I'd do this by 
        telling you a thing or two about why I choose to do things on my own rather than go through the more traditional and conventional pathway that most 
        students today take. 
    </p>

    <p>
        The biggest reason for me doing this is because I do not enjoy neither what is taught at school nor how learning is done at these institutes. 
        I do not enjoy the process of sitting in a lecture listening to a professor talk about (or "teach") the subject when they themselves give no shit about 
        what is being taught. 
    </p>

    <p>
        Another reason why I don't enjoy school is that most classrooms are set up such that the lecturer is the one with the most authority in the room. By this I mean that 
        anything the lecturer said should be taken as granted and that you as a student should never question what or how a lecture is delivered.
    </p>

    <p>
        Once, when I was in a Theory of Computation lecture, the professor said something that was not exactly correct. It is known that the pumping lemma can be used to 
        prove the nonregularity of a language. Instead of asserting this, the professor claimed (incorrectly) that the pumping lemma can be used to show that a language is 
        regular. I corrected the professor, and was quickly told in a stern manner that I was wrong and that what he said was correct.  
    </p>

    <p>
        Also, I don't enjoy school because most students that are in the same program as you are there not 
        because they enjoy or are interested in learning about computer systems, but are there really for the degree. 
        All they really care about is this piece of paper that they think is going to differentiate them from other applicants, and that is somehow going to guarantee them a job.
        Hello? Everyone else in the room is getting the same piece of paper, how exactly is it going to give you an edge in your job search?
    </p>

    <p>
        I had better talks about computers with a friend from a mechanical engineering degree than any talks I've had with my peers.
    </p>

    <p>
        About two years ago, I took a computer architecture course in school. We learned about the binary representation of numbers, 
        and also took a very shallow look at the CPU fetch cycle and the memory hierarchy. What do I mean by very shallow? We learned that 
        a CPU fetches instructions from memory, decoded the instruction, and executed it; and were shown a diagram of the memory hierarchy 
        pyramid. That was 80% of the entire course. We didn't learn what the ISA is, what pipelining is, how memory is implemented, 
        how cache is implemented; we didn't even look at a single line of assembly code.
    </p>

    <p>
        Can you imagine that? A computer science degree, given to someone who has never seen a single 
        line of assembly code.
    </p>

    <h2>What Now?</h2>

    <p>
        Two years into my 3-year degree program, I now have to make a very important decision. Do I continue my journey at school, knowing that 
        I will be very dissatisfied by it at the end; or do I make a pivot now and start <b>really</b> learning about what there is to learn about 
        computer science? I made this decision 3 months ago, and the plan I went with is the latter (my formal studies are on hold; I am also considering dropping out). 
    </p>

    <p>
        The past three months have been extremely fruitful, I went through 5 textbooks, learned a ton about 
        <a href="https://eclass.teicrete.gr/modules/document/file.php/TP326/%CE%98%CE%B5%CF%89%CF%81%CE%AF%CE%B1%20(Lectures)/Computer_Networking_A_Top-Down_Approach.pdf">computer networking</a>, 
        <a href="https://mitpress.mit.edu/sites/default/files/sicp/full-text/book/book.html">programming fundamentals</a>, 
        <a href="https://csapp.cs.cmu.edu/">computer architecture</a>, 
        <a href="https://algs4.cs.princeton.edu/home/">algorithms and data structure</a>, and 
        <a href="https://condor.depaul.edu/~sepp/DM5e.htm">discrete mathematics</a>. 
        I am currently going through a 
        <a href="https://www.pearson.com/us/higher-education/program/Chartrand-Mathematical-Proofs-A-Transition-to-Advanced-Mathematics-4th-Edition/PGM1763590.html">math proof textbook </a>
        and also a slightly more intricate <a href="https://ocw.mit.edu/courses/electrical-engineering-and-computer-science/6-042j-mathematics-for-computer-science-fall-2010/index.htm">mathematics for computer science</a> course.
    </p>

    <p>
        Next on the list are textbooks on 
        <a href="http://pages.cs.wisc.edu/~remzi/OSTEP/">operating systems</a>, 
        <a href="https://www.elsevier.com/books/engineering-a-compiler/cooper/978-0-12-088478-0">compiler theory</a>, 
        <a href="https://notendur.hi.is/mae46/Haskolinn/5.%20misseri%20-%20Haust%202018/Formleg%20ma%CC%81l%20og%20reiknanleiki/Introduction%20to%20the%20theory%20of%20computation_third%20edition%20-%20Michael%20Sipser.pdf">computation theory</a>, 
        along with some math subjects such as 
        <a href="https://www.amazon.com/Calculus-4th-Michael-Spivak/dp/0914098918">calculus</a>, 
        <a href="https://math.mit.edu/~gs/linearalgebra/">linear algebra</a>, 
        statistics and probability (haven't decided on a book yet). 
        Eventually I want to get into AI topics such as 
        <a href="https://web.stanford.edu/~hastie/ElemStatLearn/">statistical learning</a>, 
        <a href="https://www.deeplearningbook.org/">deep learning</a>, 
        <a href="https://web.stanford.edu/class/psych209/Readings/SuttonBartoIPRLBook2ndEd.pdf">reinforcement learning</a>, and 
        <a href="http://aima.cs.berkeley.edu/">AI: AMA</a>.
    </p>

    <p>
        My expected timeline for completing the entire list is ~3 years. This is assuming that I do not get a job in this 3 year period. 
        I am not actively looking for a job at the moment, but that will probably change, especially when I start getting more pressure from my 
        parents to look for one.
    </p>

    <p>
        If you are an employer or a recruiter whos interested in hiring a junior software engineer, you can contact me via <a class="link" href="mailto:lowysng@gmail.com">email</a>.
        You can find a list of my skills/projects at the top of this website.
    </p>

    <hr>

    <h2>Reading List</h2>
    <p>Ongoing</p>
    <ul>
        <li>Mathematics for Computer Science (Leighton & van Dijk)</li>
        <li>Mathematical Proofs (Chartrand, Polimeni & Zhang)</li>
    </ul>
    <p>Finished</p>
    <ul>
        <li>[Jan 2020] Discrete Mathematics (Epps)</li>
        <li>[Dec 2020] SICP (Abelson & Sussman)</li>
        <li>[Dec 2020] Computer Architecture (Bryant & O'Hallaron) - first 6 chapters</li>
        <li>[Dec 2020] Algorithms and Data Structures I (Sedgewick & Wayne)</li>
        <li>[Nov 2020] Computer Networking (Kurose & Ross)</li>
    </ul>
    <p>Not yet started</p>
    <ul>
        <li>Calculus (Spivak)</li>
        <li>Linear Algebra (Strang)</li>
        <li>Statistics and Probability (Haven't decided on a book yet)</li>
        <li>Computer Architecture (Bryant & O'Hallaron)</li>
        <li>Algorithms and Data Structures II (Cormen et al.)</li>
        <li>Operating Systems (Arpaci-Dusseau)</li>
        <li>Engineering a Compiler (Cooper & Torczon)</li>
        <li>Distributed Systems (Kleppman)</li>
        <li>Artificial Intelligence (Russell & Norvig)</li>
        <li>Statistical Learning (Friedman et al.)</li>
        <li>Deep Learning (Goodfellow et al.)</li>
        <li>Reinforcement Learning (Sutton & Barto)</li>
    </ul>

    <hr>

    <h2>What is a Computer? </h2>

    <p>November 2020</p>

    <p>
        I like to answer this question in two parts: bits, and instructions.
    </p>
    <h3>Bits</h3>
    <p>
        Let's start with the bits. Suppose that you are on a cliff overlooking the ocean. 
        It is currently night time and you have two flashlights on you. Your job is to use 
        these flashlights to come up with a scheme to indicate to all incoming ships on whether 
        it is safe for them to dock.
    </p>
    <ul>
        <li>If it is safe to dock, shine both flashlights.</li>
        <li>Otherwise, keep flashlights turned off.</li>
    </ul>
    <p>
        To achieve this, you (and the ship captains) agree to follow these rules:
        This is a very simple scheme, and it works. Try to understand what is going on here.
        The actual turning on/off of the flashlights is physically unrelated to whether it is safe 
        or unsafe for the ships to dock. But since all parties have agreed beforehand on what the 
        meaning of each action is, these actions now carry a different meaning that is present only 
        in this specific context. In all other contexts, the turning on/off of the flashlights is 
        meaningless, or worse, it could carry a different meaning, which may lead to misunderstandings and 
        possibly harm.
    </p>
    <p>
        This process of using one thing to represent another thing is called symbolism.
        Symbolism is a very fundamental idea in computer science. We know that computers 
        read bits (ones and zeros). One of the reasons computers are so ubiquitous today is because of 
        the fact that these lowly bits are capable of representing not just anything, but a <i>very large</i> number 
        of anything.
    </p>
    <p>
        At the software level, we use 
        one piece of code (variables) to represent other pieces of code. At the hardware level, voltages 
        on electrical circuits are used to represent bits (ones and zeros), which are in turn used to 
        represent data and instructions. The pictures that you upload onto the Internet, the articles 
        that you read, the videos that you watch, all of these things exist as nothing but 
        mere ones and zeros.
    </p>
    <h3>Instructions</h3>
    <p>
        We just saw how bits can be used to represent information. Let's now take a very shallow look 
        at how a computer reads and executes computer instructions.
    </p>
    <p>
        Essentially, a computer does one thing, and one thing only -- execute instructions. A typical 
        sequence of computer instructions might consist of the following:
    </p>
    <ol>
        <li>Read a string of bits in memory.</li>
        <li>Read a different string of bits in memory.</li>
        <li>Compute the sum of these two string of bits.</li>
        <li>Store the resulting string of bits in memory.</li>
    </ol>
    <p>
        These elementary operations (reading from memory, writing into memory, performing an operation) form 
        the basis of a large subset of the set of all instructions of a modern processor. The four 
        instructions above may be written, in computer instruction form, as the following:
    </p>
    <ol class="code">
        <li>MOVE 00101010 TO 00000000</li>
        <li>MOVE 10010010 TO 00000001</li>
        <li>ADD 00000000 TO 00000001</li>
        <li>MOVE 00000001 TO 10010010</li>
    </ol>
    <p>
        The first instruction says to move the bits in memory location 00101010 into 
        memory location 00000000. The third instruction says to add the bits in memory 
        location 00000000 to the bits in memory location 00000001 (in place).
    </p>
    <p>
        But wait, computers can only read zeros and ones, how does it read the textual part 
        of the instructions, i.e. MOVE and ADD? The answer is, they don't. The instruction form 
        above is not the final form that gets read by the computer. The actual final form looks 
        something like the following:
    </p>
    <ol class="code">
        <li>00100010101000000000</li>
        <li>00101001001000000001</li>
        <li>10110000000000000001</li>
        <li>00100000000110010010</li>
    </ol>
    <p>
        If you look closely, you might notice some common characteristics between these four instructions 
        and the four instructions before them. Instructions 1, 2 and 4 all start with the same 
        four bits: 0010. You might guess that these four bits 0010 represent the MOVE instruction, and 
        you would be right. The first four bits specify the type of operation to perform (MOVE or ADD), the next 
        sixteen bits specify the source and destination memory locations.
    </p>
</body>
</html>
