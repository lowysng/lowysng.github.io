<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  <title>Low YS</title>
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <link href="style.css" rel="stylesheet">
</head>

<body>

    <h1>Hello, world!</h1>
    <p>
        My name is Low. I like to write programs and run those programs on a computer.
        Other things I enjoy: writing, board games, playing the piano, and reading.
    </p>

    <h3>Skills/Tools</h3>
    <ul>
        <li><b>Languages: </b>Javascript, Python, Scheme (Lisp), Java, C++, C</li>
        <li><b>Web development: </b>React, Redux, Nodejs, Express, MongoDB</li>
        <li><b>Machine Learning: </b>Keras, Dl4j, fastai</li>
        <li><b>General: </b>Git, Bash, Postman</li>
    </ul>

    <h3>Projects</h3>
    <ul>
        <li><a class="link">4-bit-adder</a> 4-bit adder circuit built on a breadboard </li>
        <li><a class="link" href="https://blooming-falls-50778.herokuapp.com/" target="_blank">topsecretchatroom</a> Realtime chatroom application (access code: 42)</li>
        <!-- <li><a class="link" href="http://app.witeboard.io" target="_blank">witeboard.io</a> A-levels exam questions bank</li> -->
        <li><a class="link" href="https://lowysng.github.io/genetic" target="_blank">genetic</a> Evolutionary based optimiser</li>
        <li><a class="link" href="https://lowysng.github.io/pathfinder" target="_blank">pathfinder</a> Search algorithm visualiser</li>
        <li><a class="link" href="https://github.com/lowysng/sudoku-csp" target="_blank">sudoku-csp</a> Sudoku solver as a constraint satisfaction problem</li>
        <li><a class="link" href="https://github.com/lowysng/nand2tetris-js" target="_blank">nand2tetris-js</a> General purpose computer and assembler</li>
        <li><a class="link" href="http://shielded-bastion-60589.herokuapp.com/" target="_blank">neural-network</a> Neural network trainer</li>
        <li><a class="link" href="https://github.com/lowysng/turing-py" target="_blank">turing-py</a> Turing machine simulator</li>
    </ul>

    <h3>Contact</h3>
    <p>
        I am currently actively looking for a software engineering job. You may email me at:
    </p>

    <a class="link" href="mailto:lowysng@gmail.com">lowysng@gmail.com</a>

    <hr>

    <h2>Speaking Mathematics</h2>

    <p>February 2021</p>

    <p>
        I spent the last few weeks learning how to read and write basic math proofs. It was slightly challenging, but at the end it was highly rewarding, definitely one of 
        the highest ROI activity I've done in my life. 
        The book that I used was <a href="https://www.pearson.com/us/higher-education/program/Chartrand-Mathematical-Proofs-A-Transition-to-Advanced-Mathematics-4th-Edition/PGM1763590.html">Mathematical Proofs: A Transition to Advanced Mathematics</a>
        by Chartrand et al. 
    </p>

    <p>
        The book is organized into two parts. The first part discusses basic mathematical concepts such as sets, functions, relations, cardinality, as well as introducing a host 
        of proof techniques. The second half of the book comprises of a collection of proof examples in a variety of math subfields, including number theory, calculus, linear algebra, and more.
    </p>

    <p>
        I went through the first half of the book in roughly a month's time, averaging about 3 hours daily. I studied all the examples in these first 11 chapters, and also attempted to do 
        all the odd numbered exercises at the end of each chapter. I managed to complete about 90% of these exercises. 
    </p>

    <p>
        The chapter on set cardinality was the most challenging. I skipped through subsection 11.5, which discusses the Schröder–Bernstein theorem. I also did not go through the collection of proof examples in the 
        second half of the book, as I plan to visit them slightly later in specialized textbooks.
    </p>

    <h3>What I learned</h3>

    <p>
        I will now try to summarize what I learned in a few paragraphs. A statement in mathematics is a sentence that is either true or false. Certain statements are taken to be true, these are called the axioms. 
        A mathematical proof of a statement is a sequence of logical deductions leading to the statement from a base set of axioms.
    </p>

    <p>
        There are different types of proof. In a direct proof, the statement that is being proven is derived directly from the set of assumptions.
        In a proof by contradiction, the opposite of what is to be proven is assumed to be true and a contradiction is derived.
        A proof by induction involves two steps: the base step and the inductive step. 
    </p>

    <p>
        Some concepts are common throughout all the subfields of mathematics. Among these are the sets and the functions. A set is a collection of objects. 
        A set may be a subset of another set. There is a unique set with no element called the empty set. Sets may be combined to produce other sets, through 
        operations such as union, intersection and complement.
    </p>

    <p>
        A function is a mapping from one set (called the domain) to another set (called the codomain). Every element in the domain must map to some element in 
        the codomain, and no element in the domain is mapped to more than one element in the codomain. A function is a special case of a general concept called 
        relations. 
    </p>

    <p>
        In an injective function, no two elements in the domain map to the same element in the codomain. In a surjective function, every element 
        in the codomain is mapped to by some element in the domain. A function that is both injective and surjective is called bijective. Every bijective function 
        has an inverse function that maps elements in the codomain of the original function to those in the domain.
    </p>

    <p>
        Two sets have the same cardinality (size) if there exists a bijective function from one set to the other. A set is denumerable if it has the same cardinality 
        as the infinite set of positive integers. A set is countable if either it is finite or it is denumerable (also called countably infinite). The set of integers 
        and the set of rational numbers are both countable. The set of real numbers is uncountable. It can be shown that any infinite subset of a denumerable set is 
        denumerable. 
    </p>

    <hr>

    <!-- <h2>I Went to a Bad School</h2>

    <p>February 2021</p>

    <p>
        Hello, my name is Low and I am from Malaysia (just above Singapore). These days I spend most of my time 
        going through mathematics and computer science textbooks on my own. I have a list that I want to go through (see below), and I 
        am very optimistic that I will be able to go through all the books on the list (in its preliminary form) 
        in about three year's time.
    </p>

    <p>
        Why would anyone learn anything on their own instead of doing it by going to a school? Well, the thing is that I did go to a school. But I went 
        to a very bad school, and I didn't enjoy my time there. The biggest reason why is because I was very dissatisfied with the materials 
        that were taught at school. 
    </p>

    <p>
        In my freshman year, I took a computer architecture course. We learned about binary representation of numbers, 
        and also took a very shallow look at the CPU fetch cycle and the memory hierarchy. What do I mean by very shallow? We learned that 
        a CPU fetches instructions from memory, decoded the instruction, and executed it; and were shown a diagram of the memory hierarchy 
        pyramid. That was 80% of the entire course. We didn't learn what the ISA is, what pipelining is, how memory is implemented, 
        how cache is implemented; we didn't even look at a single line of assembly code.
    </p>

    <p>
        Another reason why I didn't enjoy my time at school is that most classrooms are set up such that the lecturer is the one with the most authority in the room. By this I mean that 
        anything the lecturer said should be taken as granted and that you as a student should never question what or how a lecture is delivered.
    </p>

    <p>
        Once, when I was in a Theory of Computation lecture, the professor said something that was not exactly correct. It is known that the pumping lemma can be used to 
        prove the nonregularity of a language. Instead of asserting this, the professor claimed (incorrectly) that the pumping lemma can be used to show that a language is 
        regular. I corrected the professor, and was quickly told in a stern manner that I was wrong and that what he said was correct.  
    </p>

    <p>
        Also, most of my peers are there really just for the degree. None were really intested in computer systems.
        I had better talks about computers with a friend from a mechanical engineering degree than any talks I've had with my peers.
    </p>

    <h3>What now?</h3>

    <p>
        Two years into my 3-year degree program, I now have to make a very important decision. Do I continue my journey at school, knowing that 
        I will be very dissatisfied by it, filled with regret at the end; or do I make a pivot now and start <b>really</b> learning about what there is to learn about 
        computer science? 3 months ago, I decided to pause my formal studies and go with the latter plan. So far it has been a very positive experience, 
        so positive that I am considering dropping out of school and going full time with my plan. 
    </p>

    <p>
        The past three months have been extremely fruitful, I went through 5 textbooks, learned a ton about 
        <a href="https://eclass.teicrete.gr/modules/document/file.php/TP326/%CE%98%CE%B5%CF%89%CF%81%CE%AF%CE%B1%20(Lectures)/Computer_Networking_A_Top-Down_Approach.pdf">computer networking</a>, 
        <a href="https://mitpress.mit.edu/sites/default/files/sicp/full-text/book/book.html">programming fundamentals</a>, 
        <a href="https://csapp.cs.cmu.edu/">computer architecture</a>, 
        <a href="https://algs4.cs.princeton.edu/home/">algorithms and data structure</a>, and 
        <a href="https://condor.depaul.edu/~sepp/DM5e.htm">discrete mathematics</a>. 
        I am currently going through a 
        <a href="https://www.pearson.com/us/higher-education/program/Chartrand-Mathematical-Proofs-A-Transition-to-Advanced-Mathematics-4th-Edition/PGM1763590.html">math proof textbook </a>
        and also a slightly more intricate <a href="https://ocw.mit.edu/courses/electrical-engineering-and-computer-science/6-042j-mathematics-for-computer-science-fall-2010/index.htm">mathematics for computer science</a> course.
    </p>

    <p>
        Next on the list are textbooks on 
        <a href="http://pages.cs.wisc.edu/~remzi/OSTEP/">operating systems</a>, 
        <a href="https://www.elsevier.com/books/engineering-a-compiler/cooper/978-0-12-088478-0">compiler theory</a>, 
        <a href="https://notendur.hi.is/mae46/Haskolinn/5.%20misseri%20-%20Haust%202018/Formleg%20ma%CC%81l%20og%20reiknanleiki/Introduction%20to%20the%20theory%20of%20computation_third%20edition%20-%20Michael%20Sipser.pdf">computation theory</a>, 
        along with some math subjects such as 
        <a href="https://www.amazon.com/Calculus-4th-Michael-Spivak/dp/0914098918">calculus</a>, 
        <a href="https://math.mit.edu/~gs/linearalgebra/">linear algebra</a>, 
        statistics and probability (haven't decided on a book yet). 
        Eventually I want to get into AI topics such as 
        <a href="https://web.stanford.edu/~hastie/ElemStatLearn/">machine learning</a>, 
        <a href="https://www.deeplearningbook.org/">deep learning</a>, 
        <a href="https://web.stanford.edu/class/psych209/Readings/SuttonBartoIPRLBook2ndEd.pdf">reinforcement learning</a>, and 
        <a href="http://aima.cs.berkeley.edu/">AI: AMA</a>.
    </p>

    <p>
        My expected timeline for completing the entire list is ~3 years. This is assuming that I do not get a job in this 3 year period. 
        I am not actively looking for a job at the moment, but that will probably change, especially when I start getting more pressure from my 
        parents to look for one.
    </p>

    <p>
        If you are an employer or a recruiter whos interested in hiring a junior software engineer, 
        you can contact me via <a class="link" href="mailto:lowysng@gmail.com">email</a>.
        You can find a list of my skills/projects at the top of this website.
    </p>

    <hr> -->

    <h2>Reading List</h2>
    <p>Last Updated: February 2020</p>
    <h3>Ongoing</h3>
    <ul>
        <li>Mathematics for Computer Science (MIT OCW 6.042J)</li>
        <li>Computer Architecture (Bryant & O'Hallaron) - second read through of first 6 chapters</li>
    </ul>
    <h3>Finished</h3>
    <ul>
        <li>[Feb 2020] Mathematical Proofs (Chartrand, Polimeni & Zhang) - first 11 chapters</li>
        <li>[Jan 2020] Discrete Mathematics (Epps) - first 10 chapters</li>
        <li>[Dec 2020] SICP (Abelson & Sussman) - first 3 chapters</li>
        <li>[Dec 2020] Computer Architecture (Bryant & O'Hallaron) - first 6 chapters</li>
        <li>[Dec 2020] Algorithms and Data Structures I (Sedgewick & Wayne) - first 4 chapters</li>
        <li>[Nov 2020] Computer Networking (Kurose & Ross) - first 5 chapters and chapter 8</li>
    </ul>
    <h3>Not Yet Started</h3>
    <ul>
        <li>Algorithms and Data Structures II (Cormen et al.)</li>
        <li>Operating Systems (Arpaci-Dusseau)</li>
        <li>Engineering a Compiler (Cooper & Torczon)</li>
        <li>Distributed Systems (Kleppman)</li>
        <li>Calculus (Spivak)</li>
        <li>Linear Algebra (Strang)</li>
        <li>Statistics and Probability (Haven't decided on a book yet)</li>
        <li>Computer Architecture (Bryant & O'Hallaron)</li>
        <li>Artificial Intelligence (Russell & Norvig)</li>
        <li>Statistical Learning (Friedman et al.)</li>
        <li>Deep Learning (Goodfellow et al.)</li>
        <li>Reinforcement Learning (Sutton & Barto)</li>
    </ul>

    <hr>

    <h2>What is a Computer? </h2>

    <p>November 2020</p>

    <p>
        I like to answer this question in two parts: bits, and instructions.
    </p>
    <h3>Bits</h3>
    <p>
        Let's start with the bits. Suppose that you are on a cliff overlooking the ocean. 
        It is currently night time and you have two flashlights on you. Your job is to use 
        these flashlights to come up with a scheme to indicate to all incoming ships on whether 
        it is safe for them to dock.
    </p>
    <ul>
        <li>If it is safe to dock, shine both flashlights.</li>
        <li>Otherwise, keep flashlights turned off.</li>
    </ul>
    <p>
        To achieve this, you (and the ship captains) agree to follow these rules:
        This is a very simple scheme, and it works. Try to understand what is going on here.
        The actual turning on/off of the flashlights is physically unrelated to whether it is safe 
        or unsafe for the ships to dock. But since all parties have agreed beforehand on what the 
        meaning of each action is, these actions now carry a different meaning that is present only 
        in this specific context. In all other contexts, the turning on/off of the flashlights is 
        meaningless, or worse, it could carry a different meaning, which may lead to misunderstandings and 
        possibly harm.
    </p>
    <p>
        This process of using one thing to represent another thing is called symbolism.
        Symbolism is a very fundamental idea in computer science. We know that computers 
        read bits (ones and zeros). One of the reasons computers are so ubiquitous today is because of 
        the fact that these lowly bits are capable of representing not just anything, but a <i>very large</i> number 
        of anything.
    </p>
    <p>
        At the software level, we use 
        one piece of code (variables) to represent other pieces of code. At the hardware level, voltages 
        on electrical circuits are used to represent bits (ones and zeros), which are in turn used to 
        represent data and instructions. The pictures that you upload onto the Internet, the articles 
        that you read, the videos that you watch, all of these things exist as nothing but 
        mere ones and zeros.
    </p>
    <h3>Instructions</h3>
    <p>
        We just saw how bits can be used to represent information. Let's now take a very shallow look 
        at how a computer reads and executes computer instructions.
    </p>
    <p>
        Essentially, a computer does one thing, and one thing only -- execute instructions. A typical 
        sequence of computer instructions might consist of the following:
    </p>
    <ol>
        <li>Read a string of bits in memory.</li>
        <li>Read a different string of bits in memory.</li>
        <li>Compute the sum of these two string of bits.</li>
        <li>Store the resulting string of bits in memory.</li>
    </ol>
    <p>
        These elementary operations (reading from memory, writing into memory, performing an operation) form 
        the basis of a large subset of the set of all instructions of a modern processor. The four 
        instructions above may be written, in computer instruction form, as the following:
    </p>
    <ol class="code">
        <li>MOVE 00101010 TO 00000000</li>
        <li>MOVE 10010010 TO 00000001</li>
        <li>ADD 00000000 TO 00000001</li>
        <li>MOVE 00000001 TO 10010010</li>
    </ol>
    <p>
        The first instruction says to move the bits in memory location 00101010 into 
        memory location 00000000. The third instruction says to add the bits in memory 
        location 00000000 to the bits in memory location 00000001 (in place).
    </p>
    <p>
        But wait, computers can only read zeros and ones, how does it read the textual part 
        of the instructions, i.e. MOVE and ADD? The answer is, they don't. The instruction form 
        above is not the final form that gets read by the computer. The actual final form looks 
        something like the following:
    </p>
    <ol class="code">
        <li>00100010101000000000</li>
        <li>00101001001000000001</li>
        <li>10110000000000000001</li>
        <li>00100000000110010010</li>
    </ol>
    <p>
        If you look closely, you might notice some common characteristics between these four instructions 
        and the four instructions before them. Instructions 1, 2 and 4 all start with the same 
        four bits: 0010. You might guess that these four bits 0010 represent the MOVE instruction, and 
        you would be right. The first four bits specify the type of operation to perform (MOVE or ADD), the next 
        sixteen bits specify the source and destination memory locations.
    </p>
</body>
</html>
